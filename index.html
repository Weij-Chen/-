<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Arix Signature Christmas Tree</title>
    
    <!-- Styles -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Playfair+Display:ital,wght@0,400;0,700;1,400&display=swap" rel="stylesheet">
    <style>
      body { margin: 0; padding: 0; background-color: #010b07; overflow: hidden; }
      #root { width: 100vw; height: 100vh; }
      #loader {
        position: absolute; top: 0; left: 0; width: 100%; height: 100%;
        background: #010b07; color: #C5A059; display: flex; justify-content: center; align-items: center;
        z-index: 9999; font-family: 'Cinzel', serif; font-size: 1.5rem; transition: opacity 0.5s;
      }
    </style>

    <!-- Import Map: Pinned versions for stability -->
    <script type="importmap">
{
  "imports": {
    "react": "https://esm.sh/react@18.2.0",
    "react-dom/client": "https://esm.sh/react-dom@18.2.0/client",
    "three": "https://esm.sh/three@0.160.0",
    "@react-three/fiber": "https://esm.sh/@react-three/fiber@8.15.14?external=react,react-dom,three",
    "@react-three/drei": "https://esm.sh/@react-three/drei@9.96.1?external=react,react-dom,three,@react-three/fiber",
    "@react-three/postprocessing": "https://esm.sh/@react-three/postprocessing@2.16.0?external=react,react-dom,three,@react-three/fiber,three-stdlib",
    "framer-motion": "https://esm.sh/framer-motion@10.16.16?external=react,react-dom",
    "maath/random": "https://esm.sh/maath@0.10.7/random?external=three",
    "react-dom/": "https://esm.sh/react-dom@^19.2.3/",
    "react/": "https://esm.sh/react@^19.2.3/",
    "maath/": "https://esm.sh/maath@^0.10.8/"
  }
}
</script>
    
    <!-- Babel for JSX -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
</head>
<body>
    <div id="loader">Initializing Experience...</div>
    <div id="root"></div>

    <script type="text/babel" data-type="module">
        import React, { useState, useMemo, useRef, useLayoutEffect } from 'react';
        import { createRoot } from 'react-dom/client';
        import * as THREE from 'three';
        import { Canvas, useFrame } from '@react-three/fiber';
        import { OrbitControls, Environment, PerspectiveCamera, Stars, Sparkles } from '@react-three/drei';
        import { EffectComposer, Bloom, Vignette, Noise } from '@react-three/postprocessing';
        import { motion } from 'framer-motion';
        import * as maath from 'maath/random';

        // Hide loader when script starts execution
        const loader = document.getElementById('loader');

        // ----------------------------------------------------------------------
        // TYPES & ENUMS
        // ----------------------------------------------------------------------
        const TreeMorphState = {
          SCATTERED: 'SCATTERED',
          TREE_SHAPE: 'TREE_SHAPE',
        };

        // ----------------------------------------------------------------------
        // CONSTANTS
        // ----------------------------------------------------------------------
        const FOLIAGE_COUNT = 12000;
        const ORNAMENT_COUNT = 280;
        const LIGHT_COUNT = 300;

        const COLORS = {
          emeraldDark: new THREE.Color('#002816'),
          emeraldLight: new THREE.Color('#0b6e40'),
          gold: new THREE.Color('#FFD700'),
          goldHot: new THREE.Color('#FFF6B5'),
          redLuxury: new THREE.Color('#8a1c1c'),
        };

        const TREE_CONFIG = {
          height: 12,
          radiusBase: 4.5,
          scatterRadius: 18,
        };

        const foliageVertexShader = `
          uniform float uTime;
          uniform float uMorph; 
          uniform float uPixelRatio;

          attribute vec3 aScatterPos;
          attribute vec3 aTreePos;
          attribute float aSize;

          varying vec3 vColor;
          varying float vAlpha;

          // Simple Noise
          float hash(float n) { return fract(sin(n) * 1e4); }
          float noise(vec3 x) {
              const vec3 step = vec3(110, 241, 171);
              vec3 i = floor(x);
              vec3 f = fract(x);
              float n = dot(i, step);
              vec3 u = f * f * (3.0 - 2.0 * f);
              return mix(mix(mix( hash(n + dot(step, vec3(0, 0, 0))), hash(n + dot(step, vec3(0, 0, 1))), u.z),
                             mix( hash(n + dot(step, vec3(0, 1, 0))), hash(n + dot(step, vec3(0, 1, 1))), u.z), u.y),
                         mix(mix( hash(n + dot(step, vec3(1, 0, 0))), hash(n + dot(step, vec3(1, 0, 1))), u.z),
                             mix( hash(n + dot(step, vec3(1, 1, 0))), hash(n + dot(step, vec3(1, 1, 1))), u.z), u.y), u.x);
          }

          void main() {
            vec3 targetPos = mix(aScatterPos, aTreePos, uMorph);
            float breath = noise(targetPos * 0.5 + uTime * 0.5) * 0.3 * (1.0 - uMorph * 0.5); 
            vec3 finalPos = targetPos + vec3(0.0, breath, 0.0);

            vec4 mvPosition = modelViewMatrix * vec4(finalPos, 1.0);
            gl_Position = projectionMatrix * mvPosition;

            gl_PointSize = aSize * uPixelRatio * (50.0 / -mvPosition.z);
            
            float colorMix = noise(targetPos * 2.0 + uTime * 0.2);
            vColor = mix(vec3(0.02, 0.2, 0.1), vec3(0.8, 0.7, 0.2), step(0.9, colorMix));
            vAlpha = 0.6 + 0.4 * uMorph; 
          }
        `;

        const foliageFragmentShader = `
          varying vec3 vColor;
          varying float vAlpha;

          void main() {
            vec2 coord = gl_PointCoord - vec2(0.5);
            float dist = length(coord);
            if (dist > 0.5) discard;
            float glow = 1.0 - (dist * 2.0);
            glow = pow(glow, 1.5);
            gl_FragColor = vec4(vColor, vAlpha * glow);
          }
        `;

        // ----------------------------------------------------------------------
        // COMPONENT: FoliagePoints
        // ----------------------------------------------------------------------
        const FoliagePoints = ({ morphTarget }) => {
          const pointsRef = useRef(null);
          const shaderRef = useRef(null);

          const { positions, scatterPos, treePos, sizes } = useMemo(() => {
            const positions = new Float32Array(FOLIAGE_COUNT * 3);
            const scatterPos = new Float32Array(FOLIAGE_COUNT * 3);
            const treePos = new Float32Array(FOLIAGE_COUNT * 3);
            const sizes = new Float32Array(FOLIAGE_COUNT);

            const sphereBox = maath.inSphere(new Float32Array(FOLIAGE_COUNT * 3), { radius: TREE_CONFIG.scatterRadius });

            for (let i = 0; i < FOLIAGE_COUNT; i++) {
              const i3 = i * 3;
              scatterPos[i3] = sphereBox[i3];
              scatterPos[i3 + 1] = sphereBox[i3 + 1];
              scatterPos[i3 + 2] = sphereBox[i3 + 2];

              const y = (Math.random() - 0.2) * TREE_CONFIG.height; 
              const normY = 1 - (y + TREE_CONFIG.height * 0.2) / TREE_CONFIG.height;
              const radiusAtHeight = Math.max(0, normY * TREE_CONFIG.radiusBase);
              const angle = Math.random() * Math.PI * 2;
              const r = Math.sqrt(Math.random()) * radiusAtHeight;

              treePos[i3] = Math.cos(angle) * r;
              treePos[i3 + 1] = y;
              treePos[i3 + 2] = Math.sin(angle) * r;

              positions[i3] = 0; positions[i3+1] = 0; positions[i3+2] = 0;
              sizes[i] = Math.random() * 0.5 + 0.5;
            }

            return { positions, scatterPos, treePos, sizes };
          }, []);

          const uniforms = useMemo(() => ({
            uTime: { value: 0 },
            uMorph: { value: 0 },
            uPixelRatio: { value: window.devicePixelRatio }
          }), []);

          useFrame((state, delta) => {
            if (shaderRef.current) {
              shaderRef.current.uniforms.uTime.value += delta;
              shaderRef.current.uniforms.uMorph.value = THREE.MathUtils.lerp(
                shaderRef.current.uniforms.uMorph.value, 
                morphTarget, 
                delta * 2.5
              );
            }
          });

          return (
            <points ref={pointsRef}>
              <bufferGeometry>
                <bufferAttribute attach="attributes-position" count={FOLIAGE_COUNT} array={positions} itemSize={3} />
                <bufferAttribute attach="attributes-aScatterPos" count={FOLIAGE_COUNT} array={scatterPos} itemSize={3} />
                <bufferAttribute attach="attributes-aTreePos" count={FOLIAGE_COUNT} array={treePos} itemSize={3} />
                <bufferAttribute attach="attributes-aSize" count={FOLIAGE_COUNT} array={sizes} itemSize={1} />
              </bufferGeometry>
              <shaderMaterial
                ref={shaderRef}
                vertexShader={foliageVertexShader}
                fragmentShader={foliageFragmentShader}
                transparent
                depthWrite={false}
                blending={THREE.AdditiveBlending}
                uniforms={uniforms}
              />
            </points>
          );
        };

        // ----------------------------------------------------------------------
        // COMPONENT: Ornaments
        // ----------------------------------------------------------------------
        const Ornaments = ({ morphTarget }) => {
          const boxMeshRef = useRef(null);
          const sphereMeshRef = useRef(null);
          const currentMorph = useRef(0);

          const { boxData, sphereData } = useMemo(() => {
            const boxes = [];
            const spheres = [];
            for (let i = 0; i < ORNAMENT_COUNT; i++) {
              const isBox = Math.random() > 0.6;
              const sPos = new THREE.Vector3(
                (Math.random() - 0.5) * TREE_CONFIG.scatterRadius * 2,
                (Math.random() - 0.5) * TREE_CONFIG.scatterRadius * 2,
                (Math.random() - 0.5) * TREE_CONFIG.scatterRadius * 2
              );

              const y = (Math.random() - 0.2) * (TREE_CONFIG.height * 0.9);
              const normY = 1 - (y + TREE_CONFIG.height * 0.2) / TREE_CONFIG.height;
              const rBase = Math.max(0, normY * TREE_CONFIG.radiusBase);
              const r = rBase + (Math.random() * 0.5);
              const angle = Math.random() * Math.PI * 2;
              const tPos = new THREE.Vector3(Math.cos(angle) * r, y, Math.sin(angle) * r);

              const color = Math.random() > 0.7 ? COLORS.gold : (Math.random() > 0.5 ? COLORS.redLuxury : COLORS.emeraldLight);
              const data = {
                id: i,
                scatterPosition: sPos,
                treePosition: tPos,
                rotation: new THREE.Vector3(Math.random()*3, Math.random()*3, 0),
                scale: Math.random() * 0.3 + 0.2,
                color: color,
                speed: Math.random() * 0.02 + 0.01
              };
              if (isBox) boxes.push(data); else spheres.push(data);
            }
            return { boxData: boxes, sphereData: spheres };
          }, []);

          useLayoutEffect(() => {
            if (boxMeshRef.current) {
              boxData.forEach((data, i) => boxMeshRef.current.setColorAt(i, data.color));
              boxMeshRef.current.instanceColor.needsUpdate = true;
            }
            if (sphereMeshRef.current) {
              sphereData.forEach((data, i) => sphereMeshRef.current.setColorAt(i, data.color));
              sphereMeshRef.current.instanceColor.needsUpdate = true;
            }
          }, [boxData, sphereData]);

          const dummy = useMemo(() => new THREE.Object3D(), []);

          useFrame((state, delta) => {
            currentMorph.current = THREE.MathUtils.lerp(currentMorph.current, morphTarget, delta * 2.0);
            const m = currentMorph.current;
            const time = state.clock.elapsedTime;

            if (boxMeshRef.current) {
              boxData.forEach((data, i) => {
                dummy.position.lerpVectors(data.scatterPosition, data.treePosition, m);
                dummy.position.y += Math.sin(time * 2 + data.id) * 0.1 * (1 - m) + Math.sin(time + data.id) * 0.05;
                dummy.rotation.x = data.rotation.x + time * data.speed * (1 - m * 0.8);
                dummy.rotation.y = data.rotation.y + time * data.speed;
                dummy.scale.setScalar(data.scale * (0.8 + 0.2 * Math.sin(time * 3 + data.id)));
                dummy.updateMatrix();
                boxMeshRef.current.setMatrixAt(i, dummy.matrix);
              });
              boxMeshRef.current.instanceMatrix.needsUpdate = true;
            }

            if (sphereMeshRef.current) {
              sphereData.forEach((data, i) => {
                dummy.position.lerpVectors(data.scatterPosition, data.treePosition, m);
                dummy.position.y += Math.cos(time * 1.5 + data.id) * 0.15 * (1 - m);
                dummy.rotation.set(0,0,0);
                dummy.scale.setScalar(data.scale);
                dummy.updateMatrix();
                sphereMeshRef.current.setMatrixAt(i, dummy.matrix);
              });
              sphereMeshRef.current.instanceMatrix.needsUpdate = true;
            }
          });

          return (
            <group>
              <instancedMesh ref={boxMeshRef} args={[undefined, undefined, boxData.length]} castShadow receiveShadow>
                <boxGeometry args={[1, 1, 1]} />
                <meshStandardMaterial roughness={0.2} metalness={0.8} envMapIntensity={1.5} />
              </instancedMesh>
              <instancedMesh ref={sphereMeshRef} args={[undefined, undefined, sphereData.length]} castShadow receiveShadow>
                <sphereGeometry args={[0.5, 32, 32]} />
                <meshStandardMaterial roughness={0.1} metalness={0.9} envMapIntensity={2.0} />
              </instancedMesh>
            </group>
          );
        };

        // ----------------------------------------------------------------------
        // COMPONENT: Mascots
        // ----------------------------------------------------------------------
        const Mascots = ({ morphTarget }) => {
          const MASCOT_COUNT = 24;
          const mascotsData = useMemo(() => {
            return new Array(MASCOT_COUNT).fill(0).map((_, i) => {
              const type = i % 2 === 0 ? 'starboy' : 'foxgirl';
              const y = (Math.random() - 0.2) * (TREE_CONFIG.height * 0.8);
              const normY = 1 - (y + TREE_CONFIG.height * 0.2) / TREE_CONFIG.height;
              const rBase = Math.max(0, normY * TREE_CONFIG.radiusBase);
              const r = rBase + 0.8; 
              const angle = Math.random() * Math.PI * 2;
              const treePos = new THREE.Vector3(Math.cos(angle) * r, y, Math.sin(angle) * r);
              const scatterPos = new THREE.Vector3(
                (Math.random() - 0.5) * TREE_CONFIG.scatterRadius * 1.8,
                (Math.random() - 0.5) * TREE_CONFIG.scatterRadius * 1.8,
                (Math.random() - 0.5) * TREE_CONFIG.scatterRadius * 1.8
              );
              return { id: i, type, treePos, scatterPos, rotationOffset: Math.random() * Math.PI * 2, speed: 0.5 + Math.random() * 0.5 };
            });
          }, []);

          return (
            <group>
              {mascotsData.map((data) => (
                <MascotItem key={data.id} data={data} morphTarget={morphTarget} />
              ))}
            </group>
          );
        };

        const MascotItem = ({ data, morphTarget }) => {
          const groupRef = useRef(null);
          const currentMorph = useRef(0);

          const starGeom = useMemo(() => {
            const starShape = new THREE.Shape();
            const outerRadius = 0.3;
            const innerRadius = 0.15;
            for (let i = 0; i < 10; i++) {
              const r = (i % 2 === 0) ? outerRadius : innerRadius;
              const a = (i / 10) * Math.PI * 2 - Math.PI / 2;
              const x = Math.cos(a) * r;
              const y = Math.sin(a) * r;
              if (i === 0) starShape.moveTo(x, y); else starShape.lineTo(x, y);
            }
            starShape.closePath();
            return new THREE.ExtrudeGeometry(starShape, { depth: 0.1, bevelEnabled: true, bevelThickness: 0.05, bevelSize: 0.05, bevelSegments: 1 });
          }, []);

          useFrame((state, delta) => {
            currentMorph.current = THREE.MathUtils.lerp(currentMorph.current, morphTarget, delta * 2.0);
            const m = currentMorph.current;
            if (groupRef.current) {
                groupRef.current.position.lerpVectors(data.scatterPos, data.treePos, m);
                const idleRot = Math.sin(state.clock.elapsedTime * data.speed) * 0.2;
                groupRef.current.rotation.y = data.rotationOffset + (state.clock.elapsedTime * (1 - m)) + idleRot * m;
                groupRef.current.rotation.z = Math.cos(state.clock.elapsedTime * data.speed) * 0.1 * m;
                const s = 1.0 + Math.sin(state.clock.elapsedTime * 3 + data.id) * 0.05;
                groupRef.current.scale.setScalar(s);
            }
          });

          return (
            <group ref={groupRef}>
              {data.type === 'starboy' ? (
                <group>
                    <mesh geometry={starGeom} position={[0, 0.25, 0]}>
                        <meshStandardMaterial color="#FFD700" emissive="#FFD700" emissiveIntensity={0.5} roughness={0.2} metalness={0.8} />
                    </mesh>
                    <mesh position={[0, -0.1, 0]}>
                        <sphereGeometry args={[0.2, 16, 16]} />
                        <meshStandardMaterial color="#ffffff" roughness={0.5} />
                    </mesh>
                </group>
              ) : (
                <group>
                    <mesh position={[0, 0.15, 0]}>
                        <sphereGeometry args={[0.22, 16, 16]} />
                        <meshStandardMaterial color="#ff9aa2" roughness={0.3} />
                    </mesh>
                    <mesh position={[-0.15, 0.3, 0]} rotation={[0, 0, 0.5]}>
                        <coneGeometry args={[0.08, 0.2, 16]} />
                        <meshStandardMaterial color="#ff9aa2" roughness={0.3} />
                    </mesh>
                    <mesh position={[0.15, 0.3, 0]} rotation={[0, 0, -0.5]}>
                        <coneGeometry args={[0.08, 0.2, 16]} />
                        <meshStandardMaterial color="#ff9aa2" roughness={0.3} />
                    </mesh>
                     <mesh position={[0, 0.1, 0.15]}>
                        <sphereGeometry args={[0.08, 16, 16]} />
                        <meshStandardMaterial color="#ffffff" roughness={0.3} />
                    </mesh>
                     <mesh position={[0, -0.15, 0]}>
                        <capsuleGeometry args={[0.12, 0.2, 4, 8]} />
                        <meshStandardMaterial color="#ffb7b2" roughness={0.5} />
                    </mesh>
                </group>
              )}
            </group>
          );
        };

        // ----------------------------------------------------------------------
        // COMPONENT: Lights
        // ----------------------------------------------------------------------
        const Lights = ({ morphTarget }) => {
          const meshRef = useRef(null);
          const currentMorph = useRef(0);
          const dummy = useMemo(() => new THREE.Object3D(), []);

          const lightsData = useMemo(() => {
            return new Array(LIGHT_COUNT).fill(0).map((_, i) => {
                const y = (Math.random() - 0.2) * (TREE_CONFIG.height * 0.95);
                const normY = 1 - (y + TREE_CONFIG.height * 0.2) / TREE_CONFIG.height;
                const rBase = Math.max(0, normY * TREE_CONFIG.radiusBase);
                const r = rBase * 0.9; 
                const angle = Math.random() * Math.PI * 2;
                const tPos = new THREE.Vector3(Math.cos(angle) * r, y, Math.sin(angle) * r);
                const sPos = new THREE.Vector3(
                     (Math.random() - 0.5) * TREE_CONFIG.scatterRadius * 1.5,
                     (Math.random() - 0.5) * TREE_CONFIG.scatterRadius * 1.5,
                     (Math.random() - 0.5) * TREE_CONFIG.scatterRadius * 1.5
                );
                return { id: i, treePos: tPos, scatterPos: sPos, phase: Math.random() * Math.PI * 2 };
            });
          }, []);

          useFrame((state, delta) => {
            currentMorph.current = THREE.MathUtils.lerp(currentMorph.current, morphTarget, delta * 3.0);
            const m = currentMorph.current;
            const time = state.clock.elapsedTime;
            if (meshRef.current) {
                lightsData.forEach((data, i) => {
                    dummy.position.lerpVectors(data.scatterPos, data.treePos, m);
                    const blink = Math.sin(time * 3 + data.phase) * 0.5 + 0.5;
                    const scale = (0.1 + 0.1 * blink) * m; 
                    dummy.scale.setScalar(scale > 0 ? scale : 0.001);
                    dummy.updateMatrix();
                    meshRef.current.setMatrixAt(i, dummy.matrix);
                    const intensity = 0.8 + blink * 1.2;
                    const col = COLORS.goldHot.clone().multiplyScalar(intensity);
                    meshRef.current.setColorAt(i, col);
                });
                meshRef.current.instanceMatrix.needsUpdate = true;
                meshRef.current.instanceColor.needsUpdate = true;
            }
          });

          return (
            <instancedMesh ref={meshRef} args={[undefined, undefined, LIGHT_COUNT]}>
                <sphereGeometry args={[1, 16, 16]} />
                <meshBasicMaterial toneMapped={false} color={COLORS.goldHot} />
            </instancedMesh>
          );
        };

        // ----------------------------------------------------------------------
        // COMPONENT: TopStar
        // ----------------------------------------------------------------------
        const TopStar = ({ morphTarget }) => {
          const meshRef = useRef(null);
          const currentMorph = useRef(0);
          
          const starGeometry = useMemo(() => {
            const starShape = new THREE.Shape();
            const outerRadius = 1.2;
            const innerRadius = 0.5;
            for (let i = 0; i < 10; i++) {
              const r = (i % 2 === 0) ? outerRadius : innerRadius;
              const a = (i / 10) * Math.PI * 2 - Math.PI / 2;
              const x = Math.cos(a) * r;
              const y = Math.sin(a) * r;
              if (i === 0) starShape.moveTo(x, y); else starShape.lineTo(x, y);
            }
            starShape.closePath();
            return new THREE.ExtrudeGeometry(starShape, { depth: 0.4, bevelEnabled: true, bevelThickness: 0.1, bevelSize: 0.1, bevelSegments: 2 });
          }, []);

          const { treePos, scatterPos } = useMemo(() => {
            const tPos = new THREE.Vector3(0, TREE_CONFIG.height * 0.82 + 1.0, 0); 
            const sPos = new THREE.Vector3(
              (Math.random() - 0.5) * TREE_CONFIG.scatterRadius,
              (Math.random() - 0.5) * TREE_CONFIG.scatterRadius,
              (Math.random() - 0.5) * TREE_CONFIG.scatterRadius
            );
            return { treePos: tPos, scatterPos: sPos };
          }, []);

          useFrame((state, delta) => {
            currentMorph.current = THREE.MathUtils.lerp(currentMorph.current, morphTarget, delta * 2.5);
            const m = currentMorph.current;
            if (meshRef.current) {
                meshRef.current.position.lerpVectors(scatterPos, treePos, m);
                meshRef.current.position.y += Math.sin(state.clock.elapsedTime * 2) * 0.1;
                meshRef.current.rotation.y += delta * (0.5 + 2.0 * (1 - m));
                meshRef.current.rotation.z = Math.sin(state.clock.elapsedTime) * 0.1 * m; 
                const s = 1.0 + Math.sin(state.clock.elapsedTime * 3) * 0.05;
                meshRef.current.scale.setScalar(s);
            }
          });

          return (
            <mesh ref={meshRef} geometry={starGeometry} castShadow>
                <meshStandardMaterial color={COLORS.gold} emissive={COLORS.goldHot} emissiveIntensity={2.0} roughness={0.1} metalness={1.0} />
                <pointLight intensity={2} color="#fff6b5" distance={5} decay={2} />
            </mesh>
          );
        };

        // ----------------------------------------------------------------------
        // COMPONENT: Experience
        // ----------------------------------------------------------------------
        const Experience = ({ treeState }) => {
          const morphTarget = treeState === TreeMorphState.TREE_SHAPE ? 1.0 : 0.0;
          
          // Trigger loader removal
          useLayoutEffect(() => {
             if(loader) loader.style.opacity = '0';
             setTimeout(() => { if(loader) loader.style.display = 'none'; }, 500);
          }, []);

          return (
            <Canvas 
              gl={{ antialias: false, alpha: false }} 
              dpr={[1, 2]} 
              shadows
            >
              <color attach="background" args={['#000502']} />
              <PerspectiveCamera makeDefault position={[0, 2, 18]} fov={45} />
              <OrbitControls enablePan={false} minDistance={8} maxDistance={25} maxPolarAngle={Math.PI / 1.4} autoRotate={treeState === TreeMorphState.TREE_SHAPE} autoRotateSpeed={0.5} />
              
              <Environment preset="city" /> 
              <ambientLight intensity={0.2} color="#001a0f" />
              <spotLight position={[10, 20, 10]} angle={0.3} penumbra={1} intensity={2} color="#fff0d6" castShadow />
              <pointLight position={[-10, -5, -10]} intensity={1} color="#0b6e40" />

              <group position={[0, -4, 0]}>
                <FoliagePoints morphTarget={morphTarget} />
                <Ornaments morphTarget={morphTarget} />
                <Mascots morphTarget={morphTarget} />
                <Lights morphTarget={morphTarget} />
                <TopStar morphTarget={morphTarget} />
              </group>

              <Stars radius={100} depth={50} count={5000} factor={4} saturation={0} fade speed={1} />
              <Sparkles count={200} scale={20} size={2} speed={0.4} opacity={0.5} color="#ffd700" />

              <EffectComposer enableNormalPass={false}>
                <Bloom luminanceThreshold={1.4} mipmapBlur intensity={0.8} radius={0.6} />
                <Vignette eskil={false} offset={0.1} darkness={1.1} />
                <Noise opacity={0.02} />
              </EffectComposer>
            </Canvas>
          );
        };

        // ----------------------------------------------------------------------
        // COMPONENT: Overlay
        // ----------------------------------------------------------------------
        const Overlay = ({ treeState, toggleState }) => {
          const isTree = treeState === TreeMorphState.TREE_SHAPE;

          return (
            <div className="absolute inset-0 pointer-events-none flex flex-col justify-between items-center p-8 z-10">
              <header className="text-center mt-4">
                <h1 className="text-3xl md:text-5xl text-transparent bg-clip-text bg-gradient-to-b from-[#FFF6B5] to-[#C5A059] font-[Cinzel] tracking-widest drop-shadow-[0_2px_10px_rgba(255,215,0,0.3)] uppercase">
                  Christmas Tree
                </h1>
                <h2 className="text-[#0b6e40] font-[Playfair Display] italic text-xl md:text-2xl mt-2 tracking-wide opacity-80">
                  Merry Christmas
                </h2>
              </header>

              <div className="mb-12 pointer-events-auto">
                <motion.button
                  whileHover={{ scale: 1.05 }}
                  whileTap={{ scale: 0.95 }}
                  onClick={toggleState}
                  className={`
                    relative px-8 py-3 text-sm md:text-lg tracking-[0.2em] font-bold border border-[#C5A059]
                    transition-all duration-500 overflow-hidden group bg-opacity-20 backdrop-blur-sm
                    ${isTree ? 'bg-[#002816] text-[#FFD700]' : 'bg-transparent text-[#FFD700]'}
                  `}
                >
                  <span className={`absolute inset-0 w-full h-full bg-[#C5A059] transition-transform duration-500 origin-left ${isTree ? 'scale-x-0' : 'scale-x-0'}`} />
                  <span className="relative z-10 flex items-center gap-2 font-[Cinzel]">
                    {isTree ? 'SCATTER ESSENCE' : 'ASSEMBLE FORM'}
                  </span>
                  <div className="absolute inset-0 shadow-[0_0_20px_rgba(197,160,89,0.3)] rounded-sm" />
                </motion.button>
              </div>

              <div className="absolute bottom-4 left-4 text-[#0b6e40] text-xs font-[Cinzel] tracking-widest opacity-50">
                INTERACTIVE 3D EXPERIENCE
              </div>
            </div>
          );
        };

        // ----------------------------------------------------------------------
        // APP ROOT
        // ----------------------------------------------------------------------
        const App = () => {
          const [treeState, setTreeState] = useState(TreeMorphState.SCATTERED);

          const toggleState = () => {
            setTreeState((prev) => 
              prev === TreeMorphState.SCATTERED 
                ? TreeMorphState.TREE_SHAPE 
                : TreeMorphState.SCATTERED
            );
          };

          return (
            <div className="w-full h-screen bg-black relative overflow-hidden">
              <div className="absolute inset-0 z-0">
                <Experience treeState={treeState} />
              </div>
              <Overlay treeState={treeState} toggleState={toggleState} />
              <div className="absolute inset-0 pointer-events-none border-[1px] border-[#C5A059]/20 m-4 z-20 mix-blend-overlay" />
            </div>
          );
        };

        const rootElement = document.getElementById('root');
        const root = createRoot(rootElement);
        root.render(
          <React.StrictMode>
            <App />
          </React.StrictMode>
        );
    </script>
</body>
</html>
